1 demarrer le serveur localhost
puis Pour demarrer le server 
			php bin/console server:run
			
			
			
			
			---------
			SYMFONY :
			---------
SOMMAIRE : 
INTRO : Qu'est-ce que Symfony
ETAPE 1 : Installation de SF 3.4
ETAPE 2 : Les bundles
ETAPE 3 : Les routes et les controllers
ETAPE 4 : Créer la Boutique sur SF 
ETAPE 5 : TWIG (moteur de template)
ETAPE 6 : Les assets 
ETAPE 7 : Entités 
ETAPE 8 : DOCTRINE 
ETAPE 9 : Les formulaires 
ETAPE 10 : Validation des données 
ETAPE 11 : Association Mapping
ETAPE 12 : Sécurité et Utilisateurs 
ETAPE 13 : Installation et boutique sur SF 4.3
BONUS : Mise en prod
BONUS : Formulaire de contact 




--------------------------------------
INTRO : Qu'est-ce que Symfony
---------------------------------------

1/ Quel intérêt d'utiliser un Framework
	
	A. Une organisation optimisée
	B. Fonctionnalités communes à tous les projets
	C. Services disponibles (Routing, Sécurité, BDD, Moteur de template, formulaire...)
	D/ Communauté


2/ Choix du Framework 
	A. Propre Framework (pédagogie)
	B. Les frameworks fullstack (Symfony, Zend, Laravel, cake...)
	C. Les minis Frameworks (Silex, Slim, CodeIgniter, Lumen...)


3/ Symfony
	
	-> Framework Français créé par sensiolabs 
	-> versions :
		LTS (Long Time Support): 
			v2.8
			v3.4 : 2.8 plus souple (moins rigide), avec des fonctionnalités
			v4.4 : 3.4 BundleLess, Flex, Encore (webpack), Maker, PHP7.1
				
				
----------------------------------
ETAPE 1 : Installation de SF 3.4			
Sommaire : 
1/ Installer Composer
2/ Installer SF3.4
3/ Arborescence des dossiers et fichiers
4/ Lancement de l'application
------------------------------------

1/ Installer Composer

Composer est un outils de dépendance. Il permet de télécharger et de mettre à jour tous les outils (services, composants, dépendances) dont on a besoin. 

	- Télécharger : https://getcomposer.org/download/
	composer-Setup.exe
	
	- Installer : Suivre les étapes. 



2/ Installer SF3.4
	
	- Dans le dossier Symfony 
	- MAJ + clic-droit : Ouvrir une fenêtre powershell ici

	<cmd>
	composer create-project symfony/framework-standard-edition test

	==> A ce stade un dossier test a été créé. C'est un nouveau projet SF. 

3/ Arborescence des dossiers et fichiers

	- app/  : contient toute la configuration de l'app (BDD, sécurité, routes...)
	- bin/  : Les éxécutables de l'app (de SF)
	- src/  : Le dossier dans lequel nous allons coder notre MVC
 	- var/  : Les fichiers écrits par SF au fur et à mesure (cache, logs)
	- tests/ : Les tests unitaires. 
	- web/  : repertoire WEB (app.php ou app_dev.php, img/css/js/fonts)
	- vendor/ : Le coeur de SF (les fichiers codés par les sensio Labs)
	
	- composer.json : Contient la liste de toutes les dépendances dont on a besoin.


4/ Lancement de l'application			
			
	- Méthode 1 : 
	localhost/Symfony/test/web/app.php
	localhost/Symfony/test/web/app_dev.php


	- Méthode 2 : 
	On va dans le dossier test/
	<cmd>
	php bin/console server:run
	
	localhost:8000
	

	- Différence entre mode prod et dev : 
	
	localhost/Symfony/test/web/toto
	localhost:8000/toto
	
	===> A ce stade notre application affiche la page de bienvenue. Cela signifie que tout va bien. 
	

-----------------------
ETAPE 2 : Les bundles
Sommaire : 
1/ Le concept des Bundles
2/ Création de notre premier Bundle
-----------------------

1/ Le concept des Bundles
	
	- Les bundles sont des briques de notre applications. 
	
	UserBundle : 
		UserController  (C)
		UserModel (M)
		View : inscription/connexion/profil...

	Avec la nouvelle version de SF (4), on considère qu'il est préférable de créé un seul Bundle (AppBundle). 


2/ Création de notre premier Bundle

	On va créer un Bundle : POLES/TestBundle
	
	<cmd>
	php bin/console generate:bundle 
	
	-> Yes
	-> POLES/TestBundle
	-> POLESTestBundle
	-> src/
	-> annotation
	
	==> Notre Bundle a été créé, mais il faut l'enregistrer.
	
	<code>composer.json
	"psr-4": {
            "AppBundle\\": "src/AppBundle",
			"POLES\\": "src/POLES"
        },

	- Mise à jour de l'app
	<cmd>
	composer update
	
	
	===> Notre Bundle existe dans src/POLES/TestBundle
	Il est composé de 4 dossiers : 
		- Controller : les controllers du bundle 
		- DependencyInjection : Injection de dépendances.
		- Resources : Vues et Routes (YML) et enventuellement JS
		- Test : Test liés aux fonctionnalité du Bundle. 
		
		
	===> A ce stade le Bundle est fonctionnel, mais il y a une petite erreur qu'on va corriger. 
	
	- test/src/POLES/TestBundle/Controller/DefaultController.php 
	<code>
	return $this->render('POLESTestBundle:Default:index.html.twig');
    Devient : 
	return $this->render('@POLESTest/Default/index.html.twig');	
	
	
	===> A ce stade la page d'accueil affiche "Hello World". 
	
--------------------------
ETAPE 3 : Les routes et les controllers
Sommaire : 
1/ création de routes
2/ L'objet Request 
3/ L'objet Response
4/ Redirection
5/ Message
--------------------------
1/ création de routes
	("/") -> route simple homepage
    ("/bonjour/") -> route echo (erreur)
    ("/bonjour2/") -> route response
    ("/hello/{prenom}") -> route response + param URL
    ("/hola/{prenom}") -> route render de vue (html.twig) + param URL
    ("/ciao/{prenom}/{age}") -> route render de vue + 2 params URL
    ("/redirect/") -> route avec redirection (RedirectResponse)
    ("/redirect2/") -> route avec redirection (redirectToRoute())
    ("/message/") -> route avec redirect et message en session


2/ L'objet Request 
	<code>
	use Symfony\Component\HttpFoundation\Request;

	Correspond à la partie requete de la requête HTTP. 

	<code>
	$session = $request -> getSession(); 
	-> récupère la session ($_SESSION)

	Autres exemples : 
	<code>
	$session -> set('prenom', 'Yakine');
	echo $session -> get('prenom'); 

	Autre méthode :
	<code>
	$request -> session -> set('prenom', 'Yakine'); 

	
	Autres utilités de $request : 
	<code>
	$request -> query -> get('argument_url');
	$request -> request -> get('champs_form');
	$request -> cookies -> get('cookie');
	$request -> server -> get('server');
	
3/ L'objet Response

	- Correspond à la partie réponse d'une requête HTTP. 
	
	<code>
	use Symfony\Component\HttpFoundation\Response;
	
	- Toute action (fonction) doit avec une réponse. 
	
	<code>
	return new Response('toto');
	
	- Même la fonction render est une réponse. 
	
	<code>
	return $this -> render();
	return $this -> getTemplating() -> renderResponse(); 
	
	
4/ Redirection

	<code>premiere méthode : 
	use Symfony\Component\HttpFoundation\RedirectResponse;
	
	cf route "/redirect/" et "/redirect2"
	
	/!\ A ce stade toutes nos routes doivent avoir un name
	
5/ Message
	
	<code>
	$session -> getFlashBag() -> add();

	-> permet d'enregistrer des messages qui seront disponibles dans d'autres pages (messages de félicitations, ou d'erreur).
	
	-> app.session : Qui nous permet en Twig de récupérer les infos en session. 
	-> app.user : Qui nous permet en Twig de récupérer les infos de l'utilisateur actuellement connecté



--------------------------------------
ETAPE 4 : Créer la Boutique sur SF 3.4
Sommaire : 
1/ Création du projet
2/ Réorganiser le AppBundle
3/ Création des première route
--------------------------------------
1/ Création du projet

	- Dans le dossier Symfony
	<cmd>
	composer create-project symfony/framework-standard-edition Boutique3
	cd Boutique3
	php bin/console server:run
	
	Test : localhost:8000 

2/ Réorganiser le AppBundle

localhost/                 -> Produit/index.html.twig 
localhost/categorie/pull   -> Produit/index.html.twig 
localhost/produit/12       -> Produit/show.html.twig 


Admin Controller : 

localhost/admin/produit/list/  
		-> Admin/list_produit.html.twig   
		-> 'Je suis dans la page qui liste les produits'
		
localhost/admin/produit/add/  
		-> Admin/form_produit.html.twig  
		-> 'Je suis dans le formulaire produit'	
		
-> Creation de nos controllers:
    AdminController
    MembreController
    CommandeController
    ProduitController
--------------------------
    (SecurityController
    BaseController)

-> Creation de nos vues 
    Admin/      (list_produit, form_produit etc...)
    Membre/     (connexion, inscription, profil...)
    Commande/   (panier, transport, livraison, paiement...)
    Produit/    (home, categorie, boutique, fichie_produit...)



3/ Création des première route

    -> ProduitController : "/, /produit{id}/" etc...
    ->AdminController    : "/admin/produit/" , "/admin/membre/" etc...
--------------------------------------
ETAPE 5 : TWIG (moteur de template)
Sommaire :
1/ Creation du layout
2/ L'heritage Twig
3/ Modification de nos vues
4/ Documentation Twig

--------------------------------------
Twig est le moteur de template de Symfony. un moteur de template (tpl, smarty, Twig, blade...) permet d'afficher du php dans les vues HTML de maniere plus simple.

    Exemple :
    <?= $membre['prenom']?>
    {{membre.prenom}}
	

1/ Creation du layout

CHEMIN : Boutique3/app/Resources/views/layout.html.twig
un layout est une structure de page, dans laquelle on peut ajouter des elements/ contenu.
Le concept des layout permet d'avoir plusieurs structures de page dans notre site (ex: front vs backoffice).


2/ L'heritage Twig

	avec Twig on  parle d'heritage. cela signifie que nos vue hériten (extends) d'un layout, et peuvent contenir de l'HTML à l'interieur des blocks disponibles (créés dans le layout).

	======>  De maniere generale , il faut voir le fonctionnement de Twig et de la methode render comme un chargement du contenu de maniere "empilée" (analogie de la poupée russse). Render temporise (memoir tampon) le contenu, et affiche en meme temp le layout, la vue et les params.




3/ Modification de nos vues


<code>
	{% extends 'layout.html.twig' %}

	{% block content %}
		contenu HTML de la page 
	{% endblock %}

 /!\ ATTENTION : Quand on utilise l'heritage Twig, nos vue ne peuvent contenir de l'HTML qu'a l'interieur des blocks prévus pour



4/ Documentation Twig

https://twig.symfony.com/doc/2.x/

	======> a ce stade notre app permet d'afficher les pages accueil, inscription, connexion, profil, boutique, produit, categorie, gestion memebre, gestion produit, gestion commande.

	
	======>par contre nous ne somme toujours pas en mesur d'echanger avec la BDD (ajouter un contenu, et recupérer le contenu) . Il faut voir les Entity et Doctrine.


-------------------------
ETAPE 6 : ASSETS
-------------------------
connaitre les entitys et doctrines

Sommaire :

1/ Modification du fichier composer.Json 
2/ Mise a jour de l'app.
3/Dossier Web/ (photo, css , js...)
4/ Modifications des vues
----------------------------
- le composant Asset de SF nous permet de gerer les ressources (photo, img, js, font, css) et de les appeler de maniere absolue.


1/ Modification du fichier composer.Json 
<code> composer.json
"require":{
	(a la ligne28)
	"symfony/asset":"^3.4"
}

2/ Mise a jour de l'app.

<cmd>
composer update


3/Dossier Web/ (photo, css , js...)

	Boutique3/web/
	photo/ ( a recupere du site en procedural)
	css/(à créer)
		style.css
	js/(à créer)



4/ Modifications des vues

	habituelement : href="..../css/styles.css"
	-> href="{{ asset('css/styles.css') }}"

	href="inscription.php"
	-> href="{{path('inscription')}}"
 

 La fonction Asset de twig nous permet de charger une ressources(photo, css...)
 La Fonction path()  de TWIG nous permet de créer un lien vers une page (route).


	//Liens dynamiques:
	src="../../photo/<?= $pdt['photo']?>"
	src="{{ asset('photo/' ~ pdt.photo ) }}"

	href="fiche_produit.php?id=<?= $pdt['id']?>
	href="{{ path('produit',{'id':pdt.id}) }}"

	explication
	produit---> nom de la route
	id-------->parametre dynamique de la route
	pdt.id---->valeur du parametre dynamique


	href="boutique.php?categorie=<?= $pdt['categorie']?>
	href="{{ path('categorie',{'cat':cat.categorie') }}"
	@Route("/categorie/{cat}",name="categorie")
	
	explication
	categorie---> nom de la route
	cat-------->parametre dynamique de la route
	cat.categorie---->valeur du parametre dynamique




-------------------------
ETAPE 7 : ASSETS
-------------------------
Sommaire:

1/ Doctrine et le concepte des Entité (Entity)
2/ Créer les Entité Produit
3/ Annotation (mapping)
4/ Mettre a jour la BDD
5/ Generer les entités en ligne de commande
6/ Generer la BDD via les Entités
7/ Generer les entités depuis la BDD

--------------------------

1/ Doctrine et le concepte des Entité (Entity)


	- d'une certaine maniere, les entié correspondent a la partie MODEL de notre MVC, c'est la relation avec la bdd, mais en PHP et non en SQL
	-Théoriquement, nous n'avons plus besoin du SQL.

	-ORM : Object Relation Mapping

	- Nous allons créé nos entités, sous forme de classes PHP (POPO : Plain Old PHP Object), qui vont permettre a Doctrine de comprendre notre BDD et de la manipuler.
	-par exemple: Pour faire INSERT INTO Produit
		avec symfony -> $produit =new Produit;
					$em -> presist($produit);  // $em- entyti Manager
				ou	$em -> remove($produit);

					createForm($produit);

=====> pour que cela soit possible, il faut expliquer a Doctrine, quel relation existe entre la BDD et nos Entity



2/ Créer les Entité Produit

A.creation dossier Entity _> Boutique3/src/AppBundle/

src/AppBundle/Entity/

B.creation du fichier a l'interieur : Produit.php

C. Creation de notre class Produit et de nos propriétés(getter et setter)

(lie la bdd et les objets )

3/ Annotation (mapping)

	-Avec DOCTRINE ORM (objet orientattion mapping) , on parametre le mapping via les annotations .
	<code>
	use Doctrine\ORM\Mapping as ORM

	--> Voir le fichier Entity/Produit.php

	/!\ Attention : Les Annotations pour l'ID (primary KEY) sont plus longues

	Liens :	
		Basic  mapping
			https://www.doctrine-project.org/projects/doctrine-orm/en/2.6/reference/basic-mapping.html

		association mapping
			https://www.doctrine-project.org/projects/doctrine-orm/en/2.6/reference/association-mapping.html


(creation d'une nouvelle base de donnée : boutique)



4/ Mettre a jour la BDD
	<cmd>
		php bin/console doctrine:schema:update --dump-sql
	--> voir la requete	

	(php bin/console doctrine:schema:update --force
	--> executes les modif en BDD)

	====> permet aussi de créer une BDD a partir de nos entités.
	

5/ Generer les entités en ligne de commande



A. on doit connecter notre App a la BDD
	-app/Config/parameters.yml

B.
<cmd>
php bin/console doctrine:generate:entity

AppBundle:Membre
-> on suit les etapes.
===> Cela a crée le fichier Entity/Membre.php en quelques lignes de commandes

6/ Generer la BDD via les Entités

	- on peut creer les tables dans la BDD. Par contre il faut que la BDD existe deja

	<cmd>

	php bin/console doctrine:schema:update --force
	--> executes les modif en BDD


7/ Generer les entités depuis la BDD

on peut Crée les entités depuis la BDD.

<cmd>
	php bin/console doctrine:mapping:import AppBundle\Entity annotation --path=rsc/AppBundle/Entity


cette commande nous a permis de generer les Entités depuis les tables de la BDD.
-Par contre cela n'a ni genere les repository, ni les getters et setters

<code> A Ajouter dans chaque Entity</code>
@ORM\Entity(repositoryClass="AppBundle\Repository\ProduitRepository")
@ORM\Entity(repositoryClass="AppBundle\Repository\MembreRepository")
@ORM\Entity(repositoryClass="AppBundle\Repository\CommandeRepository")
@ORM\Entity(repositoryClass="AppBundle\Repository\DetailsCommandeRepository")

<cmd> 
	php bin/console doctrine:generate:entities AppBundle
---> creation des getter et setter dans chaque fichier et genere les repository



-----------------------
ETAPE 8
-----------------------

Sommaire:
1/ Le service Doctrine
2/ Acceder au service doctrine depuis les controllers 
3/ Requetes select * FROM ...
4/ Requetes select * FROM ... WHERE id =
5/ Requetes select * FROM ...WHERE....=.....
6/ Requetes select * INSERT / UPDATE
7/ requetes DELETE
8/ Create Query et Query Builder

----------------------

1/ Le service Doctrine

	Doctrine fait 2 choses :

		1/Doctrine ORM (Objet Relation Mapping)
		 Il permet de lier les tables de notre BDD a nos entités. On ne va pas manipuler la BDD, mais des Objets( la Table Produit ---> Entity Produit)

		2/ Doctrine DBAL ( DataBase Abstract Layer )
		Le DBAL est une couche qui passe au dessus de PDO. A partir de maintement on ne fait plus de requete SQL, mais on va manipuler du PHP.

		-En Resume le DBAL va nous permette de faire des SELECT, INSERT, UPDATE, DELETE, non pas via du SQL, mais via des fonction PHP, on parle de DQL (Doctrine Query Language)

		-------> Nous ne ferons plus de sql (ou presque)



2/ Acceder au service doctrine depuis les controllers 

A. il faut pouvoir utiliser les entité dont on a besoin.
	<code>
		use AppBundle\Entity\Produit;

B. Acceder au repository dans un controller:
	<code>
		$repo = $this -> getDoctrine() -> getManager();




3/ Requetes select * FROM ...

	Depuis le Repository
		<code>
			$repo = $this -getDoctrine() -> getRepository(Produit::Class);
			$produits = $repo - findAll();



4/ Requetes select * FROM ... WHERE id 

	Depuis le Repository
		<code> 
        $repo =$this ->getDoctrine()-> getRepository(Produit::class);
        $produit=$repo->find($id);


	Depuis le Manager(EntityManager)
			$em=$this->getDoctrine()->getManager();
        	$produit =$em->find(Produit::class,$id);




5/ Requetes select * FROM ...WHERE....=.....

	La fonction findBy() va nous permettre de recupérer des données de manière plus ciblée

	<code>
	$repo = $this ->getDoctrine() -> getRepository(Produit::Class);
	$produit = $repo - findBy(array('categorie'=>$cat));

ex = tout les tshirt de taille L =
						$produit = $repo - findBy(array(
							'categorie'=>'tee_shirt'
							'taille' => 'l'
							));
====> SELECT * FROM produit WHERE taille = 'l' AND categorie = 'tee-shirt' <=====

$produit = $repo - findBy(['couleur'=>'rouge'],['prix'=>'DESC'],0,10);
							----categorie------l'ordre des prix ----nmbre d'affiché (0 à 10)
====> SELECT * FROM produit WHERE couleur= 'rouge' ORDER BY prix DESC LIMIT 0,10 <=====

$produit = $repo - findOneBy(array('taille'=>'l'));
====> SELECT * FROM produit WHERE taille = 'l' LIMIT 0,1 <=====




6/ Requetes select * INSERT / UPDATE

Avec Doctrine on manipule des Ojets de class Entity(Entité)
-> Enregistrement :
	-on cree un objet vide
	-on hydrate l'objet (normalement via un formulaire)
	-on persite et on flush

<code>
        //on créér un objet de la class produit (vide)
       		$produit = new Produit;

        // on le remplis:
			$produit -> setReference('XXX');
			$produit -> setCategorie('pull');
			$produit -> setPublic('m');
			...        


        $em -> persist($produit);
        $em -> flush();
//dans le cas de plusieurs objets, le tout est envoyer avec un seul flush
(adminController.php)

-> Modification :
- Pour update une entrée, c'est la meme chose que pour ADD, à ceci pres que l'objet n'est pas vide a la base
on doit donc recupere l'objet a modifier avec la fonction find()
        


7/ requetes DELETE

-Avec doctrine on manipule des objet (entité) donc on va recupere d'abord l'objet a supprimer avec la fonction find()

<code>
      $em->remove($produit);
      $em-> flush();



8/ Create Query et Query Builder

pour effectuer des requete specifiques, nous avons 2 possibilités:

-Create Query (SQL)
-Query Builder (PHP)

===> Voir ProduitRepository

/!\ Dans l'objectif de "factoriser" notre code bous créons nos requete specifiques dans le repository, afin de les utiliser de maniere simple dans les controllers

===> Voir le ProduitController, route "/categorie/" et la fonction getAllCategories() declarée dans le ProduitRepository.

Liens:
Query Builder : https://www.doctrine-project.org/projects/doctrine-orm/en/2.6/reference/query-builder.html
Create Query : https://www.doctrine-project.org/projects/doctrine-orm/en/2.6/reference/dql-doctrine-query-language.html



























