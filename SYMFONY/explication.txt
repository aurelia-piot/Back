
1 demarrer le serveur localhost
puis Pour demarrer le server 
			php bin/console server:run

-------------------------------------------------------------------			
			composer update pour refaire des dossier chez soi
--------------------------------------------------------------------
-dl fileZilla
--------------------------------------------------------------------

			
			
			---------
			SYMFONY :
			---------
SOMMAIRE : 
INTRO : Qu'est-ce que Symfony
ETAPE 1 : Installation de SF 3.4
ETAPE 2 : Les bundles
ETAPE 3 : Les routes et les controllers
ETAPE 4 : Cr√©er la Boutique sur SF 
ETAPE 5 : TWIG (moteur de template)
ETAPE 6 : Les assets 
ETAPE 7 : Entit√©s 
ETAPE 8 : DOCTRINE 
ETAPE 9 : Les formulaires 
ETAPE 10 : Validation des donn√©es 
ETAPE 11 : Association Mapping
ETAPE 12 : S√©curit√© et Utilisateurs 
ETAPE 13 : Installation et boutique sur SF 4.3
BONUS : Mise en prod
BONUS : Formulaire de contact 
BONUS : Panier  




--------------------------------------
INTRO : Qu'est-ce que Symfony
---------------------------------------

1/ Quel int√©r√™t d'utiliser un Framework
	
	A. Une organisation optimis√©e
	B. Fonctionnalit√©s communes √† tous les projets
	C. Services disponibles (Routing, S√©curit√©, BDD, Moteur de template, formulaire...)
	D/ Communaut√©


2/ Choix du Framework 
	A. Propre Framework (p√©dagogie)
	B. Les frameworks fullstack (Symfony, Zend, Laravel, cake...)
	C. Les minis Frameworks (Silex, Slim, CodeIgniter, Lumen...)


3/ Symfony
	
	-> Framework Fran√ßais cr√©√© par sensiolabs 
	-> versions :
		LTS (Long Time Support): 
			v2.8
			v3.4 : 2.8 plus souple (moins rigide), avec des fonctionnalit√©s
			v4.4 : 3.4 BundleLess, Flex, Encore (webpack), Maker, PHP7.1
				
				
----------------------------------
ETAPE 1 : Installation de SF 3.4			
Sommaire : 
1/ Installer Composer
2/ Installer SF3.4
3/ Arborescence des dossiers et fichiers
4/ Lancement de l'application
------------------------------------

1/ Installer Composer

Composer est un outils de d√©pendance. Il permet de t√©l√©charger et de mettre √† jour tous les outils (services, composants, d√©pendances) dont on a besoin. 

	- T√©l√©charger : https://getcomposer.org/download/
	composer-Setup.exe
	
	- Installer : Suivre les √©tapes. 



2/ Installer SF3.4
	
	- Dans le dossier Symfony 
	- MAJ + clic-droit : Ouvrir une fen√™tre powershell ici

	<cmd>
	composer create-project symfony/framework-standard-edition test

	==> A ce stade un dossier test a √©t√© cr√©√©. C'est un nouveau projet SF. 

3/ Arborescence des dossiers et fichiers

	- app/  : contient toute la configuration de l'app (BDD, s√©curit√©, routes...)
	- bin/  : Les √©x√©cutables de l'app (de SF)
	- src/  : Le dossier dans lequel nous allons coder notre MVC
 	- var/  : Les fichiers √©crits par SF au fur et √† mesure (cache, logs)
	- tests/ : Les tests unitaires. 
	- web/  : repertoire WEB (app.php ou app_dev.php, img/css/js/fonts)
	- vendor/ : Le coeur de SF (les fichiers cod√©s par les sensio Labs)
	
	- composer.json : Contient la liste de toutes les d√©pendances dont on a besoin.


4/ Lancement de l'application			
			
	- M√©thode 1 : 
	localhost/Symfony/test/web/app.php
	localhost/Symfony/test/web/app_dev.php


	- M√©thode 2 : 
	On va dans le dossier test/
	<cmd>
	php bin/console server:run
	
	localhost:8000
	

	- Diff√©rence entre mode prod et dev : 
	
	localhost/Symfony/test/web/toto
	localhost:8000/toto
	
	===> A ce stade notre application affiche la page de bienvenue. Cela signifie que tout va bien. 
	

-----------------------
ETAPE 2 : Les bundles
Sommaire : 
1/ Le concept des Bundles
2/ Cr√©ation de notre premier Bundle
-----------------------

1/ Le concept des Bundles
	
	- Les bundles sont des briques de notre applications. 
	
	UserBundle : 
		UserController  (C)
		UserModel (M)
		View : inscription/connexion/profil...

	Avec la nouvelle version de SF (4), on consid√®re qu'il est pr√©f√©rable de cr√©√© un seul Bundle (AppBundle). 


2/ Cr√©ation de notre premier Bundle

	On va cr√©er un Bundle : POLES/TestBundle
	
	<cmd>
	php bin/console generate:bundle 
	
	-> Yes
	-> POLES/TestBundle
	-> POLESTestBundle
	-> src/
	-> annotation
	
	==> Notre Bundle a √©t√© cr√©√©, mais il faut l'enregistrer.
	
	<code>composer.json
	"psr-4": {
            "AppBundle\\": "src/AppBundle",
			"POLES\\": "src/POLES"
        },

	- Mise √† jour de l'app
	<cmd>
	composer update
	
	
	===> Notre Bundle existe dans src/POLES/TestBundle
	Il est compos√© de 4 dossiers : 
		- Controller : les controllers du bundle 
		- DependencyInjection : Injection de d√©pendances.
		- Resources : Vues et Routes (YML) et enventuellement JS
		- Test : Test li√©s aux fonctionnalit√© du Bundle. 
		
		
	===> A ce stade le Bundle est fonctionnel, mais il y a une petite erreur qu'on va corriger. 
	
	- test/src/POLES/TestBundle/Controller/DefaultController.php 
	<code>
	return $this->render('POLESTestBundle:Default:index.html.twig');
    Devient : 
	return $this->render('@POLESTest/Default/index.html.twig');	
	
	
	===> A ce stade la page d'accueil affiche "Hello World". 
	
--------------------------
ETAPE 3 : Les routes et les controllers
Sommaire : 
1/ cr√©ation de routes
2/ L'objet Request 
3/ L'objet Response
4/ Redirection
5/ Message
--------------------------
1/ cr√©ation de routes
	("/") -> route simple homepage
    ("/bonjour/") -> route echo (erreur)
    ("/bonjour2/") -> route response
    ("/hello/{prenom}") -> route response + param URL
    ("/hola/{prenom}") -> route render de vue (html.twig) + param URL
    ("/ciao/{prenom}/{age}") -> route render de vue + 2 params URL
    ("/redirect/") -> route avec redirection (RedirectResponse)
    ("/redirect2/") -> route avec redirection (redirectToRoute())
    ("/message/") -> route avec redirect et message en session


2/ L'objet Request 
	<code>
	use Symfony\Component\HttpFoundation\Request;

	Correspond √† la partie requete de la requ√™te HTTP. 

	<code>
	$session = $request -> getSession(); 
	-> r√©cup√®re la session ($_SESSION)

	Autres exemples : 
	<code>
	$session -> set('prenom', 'Yakine');
	echo $session -> get('prenom'); 

	Autre m√©thode :
	<code>
	$request -> session -> set('prenom', 'Yakine'); 

	
	Autres utilit√©s de $request : 
	<code>
	$request -> query -> get('argument_url');
	$request -> request -> get('champs_form');
	$request -> cookies -> get('cookie');
	$request -> server -> get('server');
	
3/ L'objet Response

	- Correspond √† la partie r√©ponse d'une requ√™te HTTP. 
	
	<code>
	use Symfony\Component\HttpFoundation\Response;
	
	- Toute action (fonction) doit avec une r√©ponse. 
	
	<code>
	return new Response('toto');
	
	- M√™me la fonction render est une r√©ponse. 
	
	<code>
	return $this -> render();
	return $this -> getTemplating() -> renderResponse(); 
	
	
4/ Redirection

	<code>premiere m√©thode : 
	use Symfony\Component\HttpFoundation\RedirectResponse;
	
	cf route "/redirect/" et "/redirect2"
	
	/!\ A ce stade toutes nos routes doivent avoir un name
	
5/ Message
	
	<code>
	$session -> getFlashBag() -> add();

	-> permet d'enregistrer des messages qui seront disponibles dans d'autres pages (messages de f√©licitations, ou d'erreur).
	
	-> app.session : Qui nous permet en Twig de r√©cup√©rer les infos en session. 
	-> app.user : Qui nous permet en Twig de r√©cup√©rer les infos de l'utilisateur actuellement connect√©



--------------------------------------
ETAPE 4 : Cr√©er la Boutique sur SF 3.4
Sommaire : 
1/ Cr√©ation du projet
2/ R√©organiser le AppBundle
3/ Cr√©ation des premi√®re route
--------------------------------------
1/ Cr√©ation du projet

	- Dans le dossier Symfony
	<cmd>
	composer create-project symfony/framework-standard-edition Boutique3
	cd Boutique3
	php bin/console server:run
	
	Test : localhost:8000 

2/ R√©organiser le AppBundle
 
	-> Cr√©ation de nos controllers: 
		AdminController
		MembreController
		CommandeController
		ProduitController

	-> cr√©ation de nos vues 
		Admin/ (list_produit, form_produit etc...)
		Membre/ (connexion, inscription, profil...)
		Commande/ (panier, transport, livraison, paiement...)
		Produit/ (home, categorie, boutique, fiche_produit...)

3/ Cr√©ation des premi√®res routes
	
	-> ProduitController : "/", "/produit/{id}/" etc...
	-> AdminController : "/admin/produit/", "/admin/membre/" etc... 
		


-------------------------
ETAPE 5 : TWIG (moteur de template)
Sommaire : 
1/ Cr√©ation du layout
2/ L'h√©ritage Twig
3/ Modification de nos vues 
4/ Documentation Twig
--------------------

 TWIG est le moteur de template de Symfony. Un moteur de template (tpl, smarty, Twig, blade...) permet d'afficher du php dans les vues HTML de mani√®re plus simple. 

	exemple : 
	<?= $membre['prenom'] ?>
	{{ membre.prenom }}


1/ Cr√©ation du layout

	Chemin : Boutique3/app/Resources/views/layout.html.twig
	
	Un layout est une structure de page, dans laquelle on peut ajouter des √©l√©ments/du contenu. 
	Le concept des layout permet d'avoir plusieurs structures de pages dans notre site (ex: front vs backoffice).
	
2/ L'h√©ritage Twig

	Avec Twig on parle d'h√©ritage. Cela signifie que nos vues h√©ritent (extends) d'un layout, et peuvent contenir de l'HTML √† l'int√©rieur des block disponibles (cr√©√©s dans le layout). 
	
	
====> De mani√®re g√©n√©rale, il faut voir le fonctionnement de Twig et de la m√©thode render comme un chargement du contenu de mani√®re "empil√©e" (analogie de la poup√©e russe). Render temporise (m√©moire tempon) le contenu, et affiche en m√™me temps le layout, la vue et les params. 

3/ Modification de nos vues 

	<code>
	{% extends 'layout.html.twig' %}
	{% block content %}
	Contenu HTML de la page
	{% endblock %}	

	/!\ ATTENTION : Quand on utilise l'h√©ritage Twig, nos vues ne peuvent contenir de l'HTML qu'√† lint√©rieur des blocks pr√©vus pour. 

4/ Documentation Twig	

	https://twig.symfony.com/doc/2.x/

====> A ce stade notre app permet d'afficher les pages accueil, inscription, connexion, profil, boutique, produit, categorie, gestion membre, gestion produit, gestion commande. 

====> Par contre nous ne sommes pas encore en mesure d'√©changer avec la BDD (ajouter un contenu, et r√©cup√©rer le contenu). Il faut voir les Entity et Doctrine. 

-----------------
ETAPE 6 : ASSETS
-----------------
Sommaire : 
1/ Modification du fichier composer.json
2/ Mise √† jour de l'app. 
3/ Dossier Web/ (photo, css/ js...)
4/ modifications des vues. 
-------------------------------

 - Le composant Asset de SF nous permet de g√©rer les ressources (photo, img, js, fonts, css...) et de les appeler de mani√®re absolue. 

1/ Modification du fichier composer.json

	<code> composer.json
	"require": {
		"symfony/asset": "^3.4"
	}

2/ Mise √† jour de l'app. 
	
	<cmd>
	composer update


3/ Dossier Web/ (photo, css/ js...)

	Boutique3/web/
		photo/ (√† r√©cup√©rer du site en proc√©dural)
		css/ (√† cr√©er)
			styles.css
		js/ (√† cr√©er)


4/ modifications des vues. 

	
	href="../../css/styles.css"
	-> href="{{ asset('css/styles.css') }}"

	href="inscription.php"
	-> href="{{ path('inscription') }}"

	
	La fonction asset() de TWIG nous permet de charger une ressource (photo, css, js, fonts...)
	
	La fonction path() de TWIG nous permet de cr√©er un lien vers une page (route). 
	
	
	





-----------------
ETAPE 7 : Entit√©s
-----------------
Sommaire: 
1/ Doctrine ORM et le concept des Entit√©s (Entity)
2/ Cr√©er Entit√©s Produit
3/ Annotations (mapping)
4/ Mettre √† jour la BDD 
5/ G√©n√©rer les Entit√©s en ligne de commande
6/ G√©n√©rer la BDD via les Entit√©s
7/ G√©n√©rer les entit√©s depuis la BDD
------------------

1/ Doctrine ORM et le concept des Entit√©s (Entity)

	- D'une certaine mani√®re, les entit√©s correspondent √† la partie MODEL de notre MVC. C'est la relation avec la BDD, mais en PHP et non en SQL. 
	- Th√©oriquement, nous n'avons plus besoin du SQL. 
	 
	- ORM : Object Relation Mapping 
	
	- Nous allons cr√©√© nos entit√©s, sous forme de classes PHP (POPO : Plain Old PHP Object), qui vont permettre √† Dcotrine de comprendre notre BDD et de la manipuler. 
	
	Par exemple : Pour faire INSERT INTO Produit
	
	$produit = new Produit;
	persist($produit);
	remove($produit);
	createForm($produit);


	===> Pour que cela soit possible, il faut expliquer √† Doctrine, quelle relation existe entre la BDD et nos Entity. 


2/ Cr√©er Entit√©s Produit

	A. Cr√©er le dossier src/AppBundle/Entity/
	B. Cr√©er le fichier src/AppBundle/Entity/Produit.php
	C. Cr√©er notre class Produit et nos propri√©t√©s et les getters et les setters

3/ Annotations (mapping)
	
	- Avec Doctrine ORM, on param√®tre le mapping via les annotations. 
	<code>
	use Doctrine\ORM\Mapping as ORM

	--> Voir le fichier Entity/Produit.php 

	/!\ Attention : Les annotations pour l'ID (primary KEY) sont plus longues


	Liens : 
	Basic Mapping : 
	https://www.doctrine-project.org/projects/doctrine-orm/en/2.6/reference/basic-mapping.html
	
	Association Mapping : 
	https://www.doctrine-project.org/projects/doctrine-orm/en/2.6/reference/association-mapping.html


4/ Mettre √† jour la BDD

	<cmd>
	php bin/console doctrine:schema:update --dump-sql
	--> voir la requete

	php bin/console doctrine:schema:update --force
	--> ex√©cute les modifs en BDD
	
	==> Permet aussi de cr√©er une BDD √† partir de nos entit√©s. 

 
5/ G√©n√©rer les Entit√©s en ligne de commande

	A. On doit connecter notre app (projet SF) √† la BDD
		- app/Config/parameters.yml
	
	B.
	<cmd>
	php bin/console doctrine:generate:entity
	
	AppBundle:Membre
	-> On suit les √©tapes. 
	
	===> Cela a cr√©√© le fichier Entity/Membre.php en quelques lignes de commandes. 
	

6/ G√©n√©rer la BDD via les Entit√©s
	- On peut cr√©er la BDD, depuis les entit√©s d√©j√† cod√©es

	<cmd>
	php bin/console doctrine:schema:update --force
	--> cr√©er les tables dans la BDD. Par contre il faut que la BDD existe d√©j√†. 


7/ G√©n√©rer les entit√©s depuis la BDD

	- On peut cr√©er les entit√©s depuis la BDD. 
	
	<cmd>
	php bin/console doctrine:mapping:import AppBundle\Entity annotation --path=src/AppBundle/Entity


	==> Cette commande nous a permis de g√©n√©rer les Entit√©s depuis les tables de la BDD. 
	- Par contre cela n'a ni g√©n√©r√© les repository, ni les getters et setter
	
	<code> A Ajouter dans chaque Entity
	@ORM\Entity(repositoryClass="AppBundle\Repository\ProduitRepository")
	@ORM\Entity(repositoryClass="AppBundle\Repository\CommandeRepository")
	@ORM\Entity(repositoryClass="AppBundle\Repository\MembreRepository")
	@ORM\Entity(repositoryClass="AppBundle\Repository\DetailsCommandeRepository")

	<cmd>
	php bin/console doctrine:generate:entities AppBundle
	
	==> Cela nous cr√©er nos getter et setters et g√©n√®re les repository :) :) 

----------------------
ETAPE 8 : DOCTRINE 
Sommaire : 
1/ Le service Doctrine
2/ Acc√©der au service doctrine depuis les controllers
3/ Requetes SELECT * FROM ...
4/ Requetes SELECT * FROM .... WHERE id = 
5/ Requetes SELECT * FROM .... WHERE .... = .....
6/ Requetes INSERT / UPDATE
7/ Requetes DELETE 
8/ Create Query et Query Builder
---------------------------------------
1/ Le service Doctrine

	Doctrine fait 2 choses : 
		
		1/ Doctrine ORM (Object Relation Mapping)
		Il permet de lier les tables de notre BDD √† nos entit√©s. On ne va pas manipuler la BDD, mais des objets (la table Produit ---> Entity Produit)

		2/ Doctrine DBAL (DataBase Abstract Layer)
		Le BDAL est une couche qui passe au-dessus de PDO. A partir de maintenant on ne fait plus de requ√™te SQL, mais on va manipuler du PHP. 

		- En r√©sum√© le DBAL va nous permettre de faire des SELECT, INSERT, UPDATE, DELETE, non pas via du SQL, mais via des fonction PHP. On parle de DQL (Doctrine Query Language)
	
		----> NOUS NE FERONS PLUS DE SQL (ou presque)

2/ Acc√©der au service doctrine depuis les controllers

	A. Il faut pouvoir manipuler les entit√©s dont on a besoin. 
	<code>
	use AppBundle\Entity\Produit; 
	
	B. Acc√©der au repository dans un controller : 
	<code>
	$repo = $this -> getDoctrine() -> getRepository(Produit::Class);
	
	C. Acc√©der au Manager (Qui peut faire des requ√™te sur toutes les tables)
	$em = $this -> getDoctrine() -> getManager();
	
	
	
3/ Requetes SELECT * FROM ...

	Depuis le repository : 
	<code>
	$repo = $this -> getDoctrine() -> getRepository(Produit::Class);
	$produits = $repo -> findAll();



4/ Requetes SELECT * FROM .... WHERE id = 
	
	- Depuis le repository : 
	<code>
	$repo = $this -> getDoctrine() -> getRepository(Produit::Class);
	$produit = $repo -> find($id);

	- Depuis le Manager :
	<code>
	$em = $this -> getDoctrine() -> getManager();
	$produit = $em -> find(Produit::class, $id);


5/ Requetes SELECT * FROM .... WHERE .... = .....

	La fonction findBy() va nous permettre de r√©cup√©rer des donn√©es de mani√®re plus cibl√©e. 
	<code>
	$repo = $this -> getDoctrine() -> getRepository(Produit::Class);
	$produit = $repo -> findBy(array('categorie' => $cat));
	$produit = $repo -> findBy(array('taille' => 'l'));
	
	
	$produit = $repo -> findBy(array(
		'categorie' => 'tee-shirt', 
		'taille' => 'l'
	));
	
	SELECT * FROM produit WHERE taille = 'l' AND categorie = 'tee-shirt'


	$produit = $repo -> findBy(['couleur' => 'rouge'], ['prix' => 'DESC'], 0, 10);
	SELECT * FROM produit WHERE couleur = 'rouge' ORDER BY prix DESC LIMIT 0,10


	$produit = $repo -> findOneBy(array('taille' => 'l')); 
	SELECT * FROM produit WHERE taille = 'l' LIMIT 0,1



6/ Requetes INSERT / UPDATE

	- Avec doctrine on manipule des Objets (Entit√©)
	
	-> Enregistrement : 
		- On cr√©√© un objet vide. 
		- On hydrate l'objet (normalement via un formulaire)
		- on persist et on flush
		
		<code>
		$produit = new Produit;
		$produit -> setTitre('dsqqsdqd')
		$produit -> setReference('ddd');
		...
		$em -> persist($produit);
		$em -> flush();

	-> Modification : 
	
		- Pour update une entr√©e, c'est la m√™me chose que pour ADD, √† ceci pr√®s que l'objet n'est pas vide √† la base. On doit donc r√©cup√©rer l'objet √† modifier avec la fonction find()
		

7/ Requetes DELETE 
	- Avec doctrine on manipule des Objets (Entit√©) donc on va r√©cup√©rer d'abord l'objet √† supprim√© avec la fonction find(). 

	<code>
	$em -> remove($produit);
	$em -> flush(); 
	
	
	



8/ Create Query et Query Builder

	Pour effectuer des requ√™tes sp√©cifiques, nous avons 2 possibilit√©s : 
	
	- Create Query (SQL)
	- Query Builder (PHP)
	
	==> VOIR ProduitRepository
	
	/!\ Dans l'objectif de "factoriser" notre code nous cr√©ons nos requ√™tes sp√©cifiques dans le Repository, afin de les utiliser de mani√®re simple dans les controller. 
	
	==> Voir le ProduitController, route "/categorie/" et la fonction GetAllCategories() d√©clar√©e dans le ProduitRepository. 
	
	Liens : 
	
	Query Builder: https://www.doctrine-project.org/projects/doctrine-orm/en/2.6/reference/query-builder.html
	
	Create Query : 
	https://www.doctrine-project.org/projects/doctrine-orm/en/2.6/reference/dql-doctrine-query-language.html
	


-------------------------
ETAPE 9 : Les formulaires 
Sommaire : 
1/ Le fonctionnement des formulaires
2/ G√©n√©rer les formulaire
3/ R√©cup√©rer les donn√©es du formulaire
4/ Personnaliser un formulaire avec Boostrap
5/ update un enregistrement
6/ Validation des donn√©es
7/ Champs file
--------------------------------

1/ Le fonctionnement des formulaires

- De la m√™me qu'on ne manipule pas des enregistrements en BDD, mais bien des objet (Entity), chaque formulaire va √™tre li√© √† une entit√©. 

- Ainsi un formulaire est li√© √† un objet...

Inscription --------> objet Membre
Ajout de produit ---> objet Produit
Modif de produit ---> objet Produit

Un formulaire est g√©n√©r√© gr√¢ce √† une classe (Type --> ProduitType)
Chaque champs d'un formulaire correspond √† une classe, service de SF. Cela permet de g√©n√©rer tous les contr√¥les sur les formulaires. 


2/ G√©n√©rer les formulaire

	<cmd>
	php bin/console generate:doctrine:form AppBundle:Produit

	===> Cela cr√©√© un dossier Form dans notre Bundle, et un fichier ProduitType.php, qui contient la construction du formulaire. 




3/ R√©cup√©rer les donn√©es du formulaire

	A. G√©n√©rer le form dans la route	
	
		<code>
		use AppBundle\Form\ProduitType
		$form = $this -> createForm(ProduitType::class, $produit);
		
	
	B. Afficher la vue du formulaire dans la vue
		
		- On envoie le formulaire √† la vue via les params
		<code>
		$params = array('produitForm' => $form -> createView())
		
		- On affiche le formulaire : 
			<code>
			{{form(produitForm)}} --> affiche tout le formulaire
			---
			{{form_row(produitForm.reference)}} --> affiche un champs (label, champs, errors)
			---
			{{form_label(produitForm.reference)}} --> affiche le label
			{{form_widget(produitForm.reference)}} --> affiche le champs
			{{form_errors(produitForm.reference)}} --> affiche les erreurs
			
			/!\ Si on affiche les champs un par un, il ne faut pas oublier : 
				{{ form_start(produitForm) }}
				{{ form_end(produitForm) }}
				
	
	C. R√©cup√©rer les donn√©es saisies
		
		<code>
		$form -> handleRequest($request);
		/!\ Cette ligne est importante pour pouvoir r√©cup√©rer les donn√©es en POST !! 
	
	

	D. Checker la validit√© du form et traiter les donn√©es (enregistrement)

		<code>
		if($form -> isSubmitted() && $form -> is valid()){
			// persist
			// flush
			// message de validation
			// redirection	
		}


4/ Personnaliser un formulaire avec Boostrap
	
	<code>app/Config/config.yml
	twig:
		form_themes:
			- 'bootstrap_4_layout.html.twig'
	

5/ update un enregistrement

	Pour update un enregistrement avec le syst√®me des formulaires sur SF, rien de plus simple. Lorsqu'on cr√©√© le formulaire dans la route, on pr√©cise un objet d√©j√† existant (cf route admin/produit/update/{id}).
	
	---> On dit qu'on hydrate le formulaire. 


6/ Validation des donn√©es

	- De base le formulaire est g√©n√©r√© par SF de mani√®re basique. Pour g√©rer nous-m√™me les contraintes, et la s√©curit√©, cela se passe dans le fichier ProduitType.php, et on utilise 'constraints' pour d√©finir les contraintes li√©es au formulaire. 
	
	-> cf ProduitType.php



7/ Champs file

	Pour la gestion des photos il faut : 
		1/ Enregistrer le nom de la photo dans la BDD
		2/ Enregistrer la photo (data) sur le serveur. 
		
	==> CF fonction uploadFile() dans l'entity Produit. 
	
	/!\ Dans notre formulaire d'ajout de produit il n'est plus necessaire d'avoir le champs photo (TEXT), mais bien un champs file (FILE) qui va r√©cup√©rer les infos de la photo upload√©e. 
	
	

Pour aller plus loin avec les formulaire et Symfony : https://symfony.com/doc/current/reference/forms/types.html

------------------------------------------
Etape 10 : Validation des donn√©es (Assert)
------------------------------------------ 
Pour aller plus loin avec la validation des donn√©es et Symfony :
https://symfony.com/doc/current/validation.html

------------------------------
Etape 11 : ASSOCIATION MAPPING
------------------------------
Sommaire : 
1/ Le concept
2/ La Documentation de Doctrine
3/ mise en place de l'association Mapping (OneToMany) pour Membre -> Commande
-----------------------------

1/ Avec Doctrine, on a pris l'habitude de travailler avec des objets (Entity) correspondant aux enregistrements dans la BDD (Mapping).

L'association Mapping nous permet de travailler avec des objets dans des objets. Exemple : Un membre peut avoir plusieurs commandes, dans ce cas, dans un objet Membre nous avons un array compos√© d'objets commande. Une commande appartient √† UN membre, dans ce cas dans un objet Commande nous avons un objet membre. 

Gr√¢ce √† ce fonctionnement il est plus n√©cessaire de faire des requ√™tes de jointure, lorsqu'on r√©cup√®re un objet, on r√©cup√®re tous les objets li√©s. 

2/ 
https://www.doctrine-project.org/projects/doctrine-orm/en/2.6/reference/association-mapping.html#association-mapping


3/ mise en place de l'association Mapping (OneToMany) pour Membre -> Commande
	
		-> Entity Membre
		-> Entity Commande

		
		-> Dans la vue list_commande.html.twig, on utilise {{ c.membre.prenom }} pour acc√©der aux infos du membre qui a pass√© la commande. 






------------------------------------------
Etape 12 : SECURITE ET UTILISATEURS
------------------------------------------ 
Sommaire : 
1/ Niveau de s√©curit√©
2/ Fichier de s√©curit√©
3/ Creation des routes
4/ Classe Membre (extends UserInterface)
5/ Layout



1/ Niveau de s√©curit√©

	- De base Symfony va consid√©rer un visiteur lambda comme un anonyme. 

	- Ensuite on va d√©finir des niveaux de s√©curit√© pour les utilisateurs connect√© :
		- ROLE_USER (user connect√©)
		- ROLE_ADMIN
		- ROLE_SUPER_ADMIN 
		
	- SF a un systeme de parefeu  : 
	
		- On d√©finit les routes que les ROLE peuvent emprunter. 
		
		-> Si un user anonyme --> homepage  = OK 
		-> Si un user anonyme --> profil  = pas OK -> connexion -> profil
		-> Si un user connect√© --> profil = OK 
		-> Si un user connect√© --> admin/produit = pas OK --> page erreur (404) 

		En fonction du visiteur et de la ressources demand√©e on peut param√©trer une r√©action. 



2/ Fichier de s√©curit√©

	<code>app/config/security.yml
	
	On d√©finie plusieurs choses : 
	- encoders (la mani√®re dont les password seront encod√©s)
	- provider (quelle ressource va servir d'utilisateur : MembreEntity, le login: username)
	- Hierarchie : La pyramide des droits
	- les routes form_login et logout (voir le point suivant)
	- Access control : qui a le droit √† quoi


	/!\ Attention le YAML est tr√®s sensible aux indentations et aux espaces. 
	





3/ Creation des routes
	
	form_login: 
		login_path: connexion (page de connexion)
		
		check_path: connexion_check (Page de checking de login/password, on doit juste la cr√©√©e, et la mettre dans l'attribut action de notre formulaire de connexion)
		
		default_target_path: homepage (La page par d√©faut sur laquelle on est dirig√© une fois connect√©. Sinon le parefeu prend le dessus)

	logout:
		path: deconnexion (La route de deconnexion. Doit exister mais est vide)
		target: homepage (page de destination, lorsqu'on se d√©connecte). 
		


4/ Classe Membre (extends UserInterface)
	
	- A partir de maintenant la classe Membre doit implements l'interface UserInterface
		
		
	--> username (getter/setter)
	--> password (getter/setter)
	--> roles (getter/setter) /!\ roles est un array 
	--> salt (getter/setter)
	
	/!\ Attention lors de l'inscription, il faut penser √† d√©finir un role_user par d√©faut. 
	
	--> public function eraseCredentials() : fonction obligatoire pour que SF prenne la main. 
	
	--> getRoles() et setRoles() au pluriel obligatoirement. 


5/ Layout

	Dans les vues on fait la distinction entre le niveau d'acces des utilisateur avec : 
		
	{{ if is_granted('IS_AUTHENTICATED_FULLY') }}  : tout le monde (sauf anonyme)
	{{ if is_granted('ROLE_USER') }}  : tous les users
	{{ if is_granted('ROLE_ADMIN') }}  : tous les admin
	
		
		
===> Le salage (cf salt.php) c'est l'id√©e de rendre un MDP quasiment inviolable en ajoutant au MDP soit une cha√Æne de caract√®re que seul le d√©veloppeur connait (petit site, petite structure), ou alors une cha√Æne al√©atoire pour chaque user... Ensuite pour la connexion, on r√©cup√®re le salage, pour reconstituer le MDP complet.


------------------------------------------
Etape 13 : Symfony
------------------------------------------ 
---------------------		
ETAPE 13 : Symfony 4		
Sommaire :
1/ Installation
2/ L'architecture
3/ Lancement de l'app
4/ Le maker
5/ Flex
-------------------


1/ installation : 
composer create-project symfony/website-skeleton Boutique4

2/ L'architecture

	- app a disparu  ----> config 
	- src/AppBundle a disparu   ---->  BundleLess sans Bundle mais toujours dans le namespace App\
	- src/Resources/ View  a disparu  ---> templates
		
	Le dossier templates prendra toutes les vues (Produit/ Admin/ Membres/ Bases) ainsi que le layout.html.twig
	
	web/ a disparu (app_dev.php, app.php, JS/CSS/Photo) ----> public (index.php, JS/CSS/Photo etc...)
	
	.env : Notre config (notamment les infos de connexion √† la bdd
	
3/ Lancement de l'app

	<cmd>
	php bin/console server:start
		ou alors
	php bin/console server:run
		
		
4/ Le maker : 		

	- Cr√©ation des Entit√©s : 
		php bin/console make:entity
		
		ou depuis la BDD : 
		php bin/console doctrine:mapping:import "App\Entity" annotation --path=src/Entity

			
	- Mise √† jours des entit√©s :
		php bin/console make:Entity --regenerate
		

	- Cr√©er les controller : 
		php bin/console make:controller 
		ProduitController 
		MembreController 
		CommandeController
		BaseController
		AdminController

	- Cr√©er les CRUD : 
		- pre-requis : Copier/coller les entit√©s
		
		copier le dossier	 boutique3/src/AppBundle/Entity
		le coller dans le dossier	boutique4/src/
	
	
		<cmd>
		php bin/console make:crud
		Membre
		Commande
		Produit
		
		
	- Cr√©er l'entit√© Membre : 
		<cmd>
	php bin/console make:user
	
	
		
Bundle : 

	- FOSUserBundle 
	- easyAdmin 
	
Flex : 

Symfony Flex : la nouvelle fa√ßon de d√©velopper avec Symfony
Les versions de Symfony 3.4 et 4.0 viennent tout juste de sortir et avec elles vient une nouvelle fa√ßon de d√©velopper des applications Symfony. D√Ætes adieu √† la Standard Edition et bonjour aux tout nouveaux symfony/skeleton, Symfony Flex et les recettes qui vont avec.

Vous avez dit Flex ?
D‚Äôun point de vue technique, Symfony Flex est juste un plugin Composer. Il se branche sur les √©v√©nements Composer d√®s lors que vous lancez une commande qui installe, met √† jour ou supprime un paquet PHP ou bundle Symfony. Son but ? Automatiser l‚Äôinstallation et la suppression de vos d√©pendances en fournissant une configuration par d√©faut sans avoir √† aller lire la doc pour trouver quelle configuration √©crire, quelles routes charger ou autre t√¢che r√©barbative √† effectuer. Et d√®s Symfony 4.0, Flex sera le moyen par d√©faut pour d√©velopper une application Symfony.

Il para√Æt qu‚Äôun bon exemple vaut mieux qu‚Äôun long discours. Alors imaginons que vous ayez une application existante en Symfony 3.3 (parce que vous √™tes un dev cool et avez effectu√© les migrations vers les derni√®res versions de Symfony au fur et √† mesure üí™). Vous voulez y ajouter une API en installant api-platform. Vous allez donc effectuer les t√¢ches suivantes :
	
	
Sources : https://afsy.fr/avent/2017/08-symfony-flex-la-nouvelle-facon-de-developper-avec-symfony


WebPack Encore : 
https://symfony.com/doc/current/frontend.html
	
















